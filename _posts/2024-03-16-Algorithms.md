---
title: Algorithmic Thinking
date: 2024-03-28
author: Shamik
---

No, computer science isn't necessarily about computers, and barely qualifies as a science (in the traditional sense of thinking). Furthermore, computer science isn't about programming and it's certainly not about the hot new software engineering job. Algorithms is your first foray into abstraction and theoretical thinking (i.e. what structures can I build with the tools that I have? Why build this over another structure?) and your programming language is your trusty toolkit. 

When learning a new algorithm, I rarely find myself in front of a computer as my first step. Instead, I opt for either a pen and paper or a whiteboard since both mathematics and algorithms require an immense amount of intuitive thinking when building theoretical foundations. The following algorithm is the way that I learn new algorithms (so that anything thrown at me is easily understood with respect to time).

# The Context & Motivation Stage

Ask yourself the following:
- What is this algorithm trying to solve? The shortest path between two points? The maximum sum of a subset?
- What kind of algorithm is this? Is it greedy? graph-based? both?

If you understand what you are trying to solve for, you can start building an intuition as to what data structures are necessary for your solution and how you would approach the situation if you were asked to solve the problem. Many of us have developed intuitions, but aren't able to articulate those intuitions as necessary to "come up with" the algorithm (in quotes because it's not magic).

# The Gathering Stage

This is arguably the most time intensive part because the quality of your understanding greatly depends on the quality of the resources you learn from. When choosing resources, I try to vet the resources based on the following criteria:
- How well is the problem we are trying to solve explained? How well is the intuitive solution explained?
- What is the computational complexity of the algorithm? How did we arrive at that conclusion?
- What is the pseudocode? Do I feel as thought this could easily translate to implementation?

# The Implementation Stage

Once you feel that you have a firm understanding of the theoretical foundations of the algorithm, follow a guide that shows you how to implement the algorithm in code. There's no problem with attempting to implement it on your own, but I find that have a guide the first time around allows me to understand the translation between the theory and the algorithm much faster compared to simply doing it on my own.

# The Solidifying Stage

Once implemented, provide unique examples and edge cases that help you round out your understanding of what inputs are allowed and how the input affects the output (i.e. define the limitations of this algorithm). Writing a few examples will help you realize when this algorithm is applicable to a given problem and when another algorithm might be more necessary.


